
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "python_doc/auto_examples/plot_tutorial1.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_python_doc_auto_examples_plot_tutorial1.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_python_doc_auto_examples_plot_tutorial1.py:


Tutorial 1: Building your first gradient
=================================================
In this example, we will derive a gradient and do some basic inspections to
determine which gradients may be of interest and what the multidimensional
organization of the gradients looks like.

.. GENERATED FROM PYTHON SOURCE LINES 11-13

We’ll first start by loading some sample data. Note that we’re using
parcellated data for computational efficiency.

.. GENERATED FROM PYTHON SOURCE LINES 13-25

.. code-block:: default



    from brainspace.datasets import load_group_fc, load_parcellation, load_conte69

    # First load mean connectivity matrix and Schaefer parcellation
    conn_matrix = load_group_fc('schaefer', scale=400)
    labeling = load_parcellation('schaefer', scale=400, join=True)

    # and load the conte69 surfaces
    surf_lh, surf_rh = load_conte69()









.. GENERATED FROM PYTHON SOURCE LINES 26-27

Let’s first look at the parcellation scheme we’re using.

.. GENERATED FROM PYTHON SOURCE LINES 27-34

.. code-block:: default


    from brainspace.plotting import plot_hemispheres

    plot_hemispheres(surf_lh, surf_rh, array_name=labeling, size=(1200, 200),
                     cmap='tab20', zoom=1.85)





.. image:: /python_doc/auto_examples/images/sphx_glr_plot_tutorial1_001.png
    :alt: plot tutorial1
    :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 35-36

and let’s construct our gradients.

.. GENERATED FROM PYTHON SOURCE LINES 36-44

.. code-block:: default


    from brainspace.gradient import GradientMaps

    # Ask for 10 gradients (default)
    gm = GradientMaps(n_components=10, random_state=0)
    gm.fit(conn_matrix)






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    GradientMaps(random_state=0)



.. GENERATED FROM PYTHON SOURCE LINES 45-49

Note that the default parameters are diffusion embedding approach, 10
components, and no kernel (use raw data). Once you have your gradients, a
good first step is to simply inspect what they look like. Let’s have a look
at the first two gradients.

.. GENERATED FROM PYTHON SOURCE LINES 49-65

.. code-block:: default


    import numpy as np

    from brainspace.utils.parcellation import map_to_labels

    mask = labeling != 0

    grad = [None] * 2
    for i in range(2):
        # map the gradient to the parcels
        grad[i] = map_to_labels(gm.gradients_[:, i], labeling, mask=mask, fill=np.nan)

    plot_hemispheres(surf_lh, surf_rh, array_name=grad, size=(1200, 400), cmap='viridis_r',
                     color_bar=True, label_text=['Grad1', 'Grad2'], zoom=1.55)





.. image:: /python_doc/auto_examples/images/sphx_glr_plot_tutorial1_002.png
    :alt: plot tutorial1
    :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 66-72

But which gradients should you keep for your analysis? In some cases you may
have an a priori interest in some previously defined set of gradients. When
you do not have a pre-defined set, you can instead look at the lambdas
(eigenvalues) of each component in a scree plot. Higher eigenvalues (or lower
in Laplacian eigenmaps) are more important, so one can choose a cut-off based
on a scree plot.

.. GENERATED FROM PYTHON SOURCE LINES 72-81

.. code-block:: default


    import matplotlib.pyplot as plt

    fig, ax = plt.subplots(1, figsize=(5, 4))
    ax.scatter(range(gm.lambdas_.size), gm.lambdas_)
    ax.set_xlabel('Component Nb')
    ax.set_ylabel('Eigenvalue')

    plt.show()



.. image:: /python_doc/auto_examples/images/sphx_glr_plot_tutorial1_003.png
    :alt: plot tutorial1
    :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 82-85

This concludes the first tutorial. In the next tutorial we will have a look
at how to customize the methods of gradient estimation, as well as gradient
alignments.


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  1.397 seconds)


.. _sphx_glr_download_python_doc_auto_examples_plot_tutorial1.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: plot_tutorial1.py <plot_tutorial1.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: plot_tutorial1.ipynb <plot_tutorial1.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
